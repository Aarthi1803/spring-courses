Cryptography:

So what happens is on the internet, basically you send information between the servers or from client to server or server to client. And when you say you are sending this data through the internet, anyone in between can check this data. we have something called man in the middle attack? Basically, they can see your data, they can modify the data. So let's say if person A says to person B "hey, let's meet at a cafe at 5 p.m." but then when the data is passing, the person C says, "okay, I want to make some modification here". So C go there, C change this data from 5 p.m to 6 p.m and C send it to B. Now here we are not just doing a passive attack where you are able to read the data. You are also doing an active attack. Now, how do we secure ourselves from this attack? Now of course we have to use some mechanism, uh, where at least other person cannot see your data. Even if they can see data, they should not be able to read it. And second, they should not be able to make the changes. Even if they make the changes, B should be able to know that something has changed. And we can do that with the help of cryptography. Now in cryptography we use a concept of encryption and decryption. So let's say when A is sending data to B now what you can do is you can do something called a encryption
here. Now to do the encryption, what we basically do is we use a key and we change our data in such a way that no one else can read it. Of course, when you send the same data to B, B cannot read that data. But then what if you can share the key with B and now B should be able to decrypt it. So encryption simply means converting your normal text to ciphertext.
And decryption simply means that you're converting your ciphertext to a normal text. So when A is writing the content, that is your normal text, but then you have to encrypt it so that no one can read it. Now even if C is able to get the data, C cannot read that because it is encrypted. Now B read data because B has a key. C has no idea what that key is. Now this key is important here. Now key can be of two different types. A key can be a symmetric key or it can be asymmetric key. 

So in the symmetric key you have keys which are same. So A and B will have the same keys. And of course this can be any normal text or normal string which you can use as a key. But they will be having the same key. So if A is encrypting the data with this key, the same key has to be there with B as well to decrypt it. That is called symmetric key cryptography. The problem with this is this key need to be shared before the communication. Of course, they cannot share this key on the internet now, because if they share this key on the internet C can see the key. And then C will say, okay I got the key. Now even if A encrypt it I can read that. So that is one challenge here. They this key need to be shared beforehand. Maybe they can meet somewhere in person, share the key and go back and do the communication again. A weird way of sharing a key. But again, it's very famous, symmetric key cryptography. It is faster. And you can also have a large key size. And the bigger the key size you have it's more secure. The challenge is of course the key sharing. And also what if you have multiple members in the network. We have D and maybe A want to do communication with D now. So of course they have to use a different key. They cannot use the same key which is shared by A and B. Or maybe if you say k1 is the key used by A and B. Now A cannot use the same key with D, they need to have a different key, let's say K2. What if A or D wants to communicate with E? Of course they have to have a different key which is K3. That's how you basically, u have multiple keys in symmetric key cryptography. And the problem is managing this key becomes difficult. What if A want to communicate with everyone? So A has to manage those number of keys. 

The solution for this is asymmetric cryptography where you don't have a symmetric key. You basically have a concept of public and private key. Now how this works for the encryption and decryption, you'll be using two keys. Encrypt using public key and a private key. And how that works is if you encrypt a data with a private key, then you have to decrypt the data with
your public key. And when you encrypt the data with public key, you have to decrypt the data with private key. So basically, uh, you have to use the opposite keys for encryption decryption. You can't use the same key for both. since only the owner knows the private key. What about the public key? Public key is known by everyone in the network. Okay, now what's the advantage of this? So let's say there's a public key and private key with the B. And now A wants to send data. Now question arises what key A will use. can I can a use a private key of B? Of course not. Private key is only known by B, but then public key is known by everyone. So let's say we have a central repository where you have all these public keys,  of all the
members in the network. So they don't have to basically ask B to give you a public key. Everyone knows what is a public key for B, and since it's a public key, there is no risk here.
Now when A wants to send this data, what A will do is A will use B's public key to encrypt. when B receives the message, B can decrypt with its own private key, and only B can do that because B knows the private key. What if C comes in between and say, "hey, I got the data, now I want to decrypt it". C can't decrypt that with C's private key.
It can be only decrypt with the B's private key. That's how you basically use asymmetric cryptography. Now there are different algorithms available. Now the question is everyone in the network will have their own private key and public key. And they know their private key and public key is known by everyone. Now when do you want to send data to E. So let's say A want to send data to E. So A will use E public key to encrypt, and E will use E private key to decrypt. So that's how basically the asymmetric works. There are different algorithms available for symmetric key. We have algorithm like AES etc. Every algorithm have their own strengths and weaknesses. Same goes for asymmetric key where you have RSA etc. So we have multiple algorithms available to use Now depending upon different situation we can use different algorithms. And some are faster, some are more secure. Let's say uh A is sending the data to B and A says  
"hey, I want to meet at 5 p.m." and maybe there's nothing secret here and the message is going on the network. Now C comes in between and say, "hey, let me just hack that packet and now let me send a new packet". And C says, "let's meet at 6 p.m". Now how C will encrypt it. So what C will do is C will use B's public key which A also did and send that message to B. And B says okay I got a message and it is encrypted. Let me use my private key to decrypt key. So that means C thinks "I have to meet at 6 p.m". Okay, so when you are using this cryptography, you are basically encrypting data and decrypting it. But there is no way to prove that the sender is the actual sender. So maybe B is thinking the message is sent by A, but it is actually sent by C. How do you maintain that, uh, identity here. Now that's where you can use something called a Digital Signature.

--------------------------------
Digital Signature:

Now we know about encryption decryption, but then there was no way to prove that the person who is sending the message is actually that person. Now, the way you can do that is with the help of digital signature. Now, what we do here is what if we don't want to secure the information, but we want to prove that we are the real person. Now in that case, what A will do is A will not encrypt the message with B's public key, which was which he was doing before. Now what A will encrypt a message with its own private key. Remember that we're not using  public key for encryption. We're using A private key. Now after encryption the packet goes to B. Now how B can decrypt it? Can I use B's private key. No. Because it is encrypted by A's private key.
And the only way you can decrypt that is with the help of A's public key. If the decryption is possible, that means that there is a proof that only A has sent it. Let's try to attack here.
What if C says I want to send this data? So when the message is going from A to B, C comes in between say, "hey, let me hack this message and message is gone". Now C is sending a new message. C is going to use C's private key. And now when it goes to B, B is not able to decrypt that with A's public key. It is only possible with the help of C's public key. And now B knows something is wrong. It's not coming from A, and that's how you prove that the data is not coming from A. 

But what if it was possible to decrypt that with A's public key. That means we have proved that A has sent it now A cannot say later that, hey, I have not sent that. A has encrypted that with its private key and only A knows its own private key. This is called digital signature. But there's one problem here. We don't have security. We do have a proof that who has sent it. But anyone can read data. You know, C can also read that data. Because when C gets this packet which says "let's meet at 5 p.m.", C is able to decrypt it because A has signed it with A's private key. And to decrypt it C can use A's public key. You hacked. so how do we secure it? So that's why we have to do double encryption.


So let's say I want to send message to B. A will use B's public key to encrypt. So first layer done. Then the same packet will be encrypted again with A's private key. So double encryption now in the packet goes to B. B says it is encrypted with A's private key. Let me decrypt it with A's public key. Decryption done. That means there's a proof that A has sent it. And then again, the package is still encrypted. So again, it will do decryption with B's private key because no one knows the B's private key. And now we got the message. And we have achieved in security as well as identity. But what if let's try to attack here. So let's say C's comes in between and say "hey I want to attack". Now C receives the package and says okay, it is encrypted with A private key. Let me decrypt it with A public key. Decryption done. But now it is still encrypted with B's public key. Can C decrypt it? No, because b has no idea what B's private key and you're safe. So this is how basically you achieve signature with encryption.

--------------------------------
Why JWT (JSON Web Tokens) ?


So let's say every day when I go to my office. So we have a cafe which is just between my home and my office. I go there to have a coffee and then I go to my office. Of course, for every coffee I have to pay some amount. Let's say I'm paying $1 per coffee every day, and I'm doing this every day, right? Now what if I can talk to them by saying, hey, you know, I come there every day and let me take a membership of a month, so maybe I can get a discount. Anyway, I'm going there every day, so what if I can get, let's say, in $20 I can get for the entire
month and now the person knows me. So basically every day we see each other. So now he knows who I am. And then he says, okay, uh, now you got $20 from you. You can come for the entire month and have a coffee. Now, I went there for first day, second day, third day, and then everything was working. So he know my face. And the problem is, what if the person changes now, of course we don't want that scenario, right? Where I go to a cafe after one week and I see another person, and then this person says, who are you? We don't want that. So maybe there should be some entry in a book where they can make an entry by saying, this person has taken a subscription of one month, and every time this person comes, we can give them a coffee.
And now, uh, let's say we have an entry there so I can go there. I can tell there should be my entry. And for the entry I also got an ID. So it's my ID is 102. And every time I go there I can say this is my ID which is 102. And they can refer in that book. So we have an ID which is 102, uh, which says Naveen Reddy subscription for one month. 
So let's say with this cafe has multiple branches okay. So it is there in my area. But let's say I go to go for some training in different cities. I go to let's say Delhi, Bangalore or Mumbai and maybe they have the branches. Of course they have scaled out well and now they have branches in different cities. So let's say if one day I am not in my hometown, I'm going to a different city and I see a cafe there. The question is, will I get the free coffee? I mean, not free, but I got the membership right, I should not, I don't have to pay for it. But then when I go there by saying, hey, you know, I have ID which is 102, please check your book. There should be my entry. What do you think? Will there be a coffee there or the entry there? Of course not, because the book is there in my hometown. It's not there in every city. So that's the problem of scaling, which I'm talking about. So what is a solution here?

The solution could be one where, uh, instead of them making an entry on their book, what if they can give me a pass, a monthly pass which says Naveen Reddy has already paid $20 for the entire month. And from this day to this date, if the person has this pass, you can give them a coffee. And that perfectly works as I can just go there in any of the branch.
Doesn't matter location. I will get the coffee. And I shared this entry pass with my friend, and now she knows that if you have that pass, you will get a free coffee. So what she did, she basically printed a fake coupon which says, Aarthi paid $20 and she will get a subscription for the entire month, but Aarthi has not done that. She is creating her own coupon just by copying my coupon. And anyone can do that, right? So she will go to a coffee shop and say, hey, I am Aarthi. I already paid for $20 for the coffee, but that coupon is not valid.
How do I verify that? So one way is cafe can sign coupon, maybe a manager sign, or maybe a company stamp or maybe a digital signature if it is online. And now that is something which can prove that this coupon is valid. So we moved from having an entry on a book and giving you an ID instead of that, give a pass itself which mentions everything. So in the pass itself, you have all the data, the person name, at what time this coupon was issued, what is the expression, expression time and the rules as well. Maybe the cafe, uh, sells a lot of different stuff apart from coffee. What I will get is only coffee, right? So those things will be mentioned on the pass. 

Now coming back to the I.T world, we have client and server where client goes to the server by saying, hey, I want a resource. Now if it's a static page, we don't have to verify who the user is. I can simply return a static page. But what if I want to change the data based on the user request? So let's say if I go to my social media app, maybe it can be Instagram, YouTube, and if I want to see the content, or maybe I go to Facebook to see my friend list, I want to see only my things, not others. Right now, in this case, the server should know who I am. I can of course claim I'm this person, but how do I verify that? That's why you're thinking about login. But after doing a login, the server is basically stateless. How do you manage that? So one way you can do it on the server side you can make an entry. So once I log in the server says okay I know who you are real now and ready. This is your session ID and that goes on with the session with the cookies in my machine. And every time I go to a server, I can use that cookie. I don't have to basically log in every time for every page. That would be weird, right? let's say you go to Facebook and every time you log in, not a good idea. So basically you have a session ID which you can use every time. And in fact we have seen that when you were talking about this spring security, we got a session ID. But what if you want to scale now? What if you don't have one server? You have multiple servers. In that case, just session ID will not work is because the session ID is there with one server. When you are scaling up, when you have a horizontal scaling, you have multiple machines. Now in this case,  all these servers can share the same database, or maybe a cache where you can say, okay, we have a session ID for this particular person every time you get a request, check in the shared database. Or maybe you can tell your load balancers which are between you and your servers, that, hey, you know, every time you get a request from Naveen, send it to server one because server one knows who Naveen is. That's one of the solution. But what if you don't do all those stuff? And every time a client goes to the server and say log in done. After that, what if server can give you a pass? The same pass which I got in the coffee shop. And now every time you go to a server you can show this pass. Hey, already paid $20 for the coffee. Give me my coffee for today.
That's one thing a client can do with that pass. But of course we have to also sign the pass, right? you don't want a unsigned pass where anyone can use it.
We have something called JWT, which stands for JSON Web Tokens. Basically, the concept is about tokens. one of the way to implement that is JWT.

-----------------------
What is JWT (JSON Web Token)?

JWT used to transfer data between two different parties and that too securely. So whenever you send a token from a server to client, it can be a normal XML as well. So if you talk about technical world, not the coffee card. So let's say in the technical world you will be having this token as a JSON data or XML data, but in XML data will be lengthy, right?
even for the small amount of data, you will be having multiple tags and stuff. Plus encrypting it will be a different task. The other way is you can use normal JSON, but again JSON will be lengthy as well. In that case we can use some encoded format. And that's why the JSON web token comes into picture. So when you get a token from the server this is what you will get.
So this is alphanumeric values but we can't read it because this is in the encoded format. So you can also decode this. And when you decode it you can see we have three sections here.
Now before that you can see there's a section of algorithms. I am now I am on jwt.io. And you can see we can use different algorithms here. Remember when I talked about the signature or encryption. Basically we can use different algorithms here. Now basically we have remember when we talked about the asymmetric and symmetric. So basically we have a choice here which is H hmac-sha256 which is symmetric. If you want to use asymmetric we can use other algorithm and higher its numbers it is better because you will be having a bigger key.


A JWT token looks like this:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.
eyJ1c2VySWQiOjEsInJvbGUiOiJBRE1JTiJ9
.
dVNd1m3jJvgL0ZpGxTtwN2tuYY2sdFV6hAvRxC5XUwU

It consists of three parts:
    Header (Metadata) → Contains algorithm & token type.
    Payload (Data/Claims) → Stores user info like ID, Role, Expiry.
    Signature (Security) → Ensures the token was not altered.

Now here you can see we have three sections. So each token will have three sections. One is the header, one is the payload and next is the signature. Now payload is very important here because this is where you send your data. So when you say a server is giving some token to the client with the information, that information stays inside the payload.
For example we got who is the subject-The person and the issuance time is this. We can also set the expiry time here. If you want you can give a comma and you can say expiry and you can give a colon and you can mention whatever time. The token of course will expire. You can set the expire time here. So this is your payload and you can send multiple data here is not just you have to send only this. We can add more data, but try to make your payload as small as possible because you'll be sending this in the header. And then there are some servers which will not accept a bigger chunk of header. So make sure that you don't put unnecessary stuff here okay. Now this is the algorithm which we are using here which is SHS226. This is what you'll be having in the header. You can change it and you can use some other algorithm. 
Next we have a signature. So when you say you want to sign it you have to use some signature. And of course you can use RSA where you get two different signatures for private key and public key. But when you are using this, you will get only one secret key which will be shared by client and server, and you can encrypt it. The problem is, when you say encryption, we are not achieving the actual encryption here. We are just saying that no one should be able to modify this token. So example, if I got a token from the server, no one else can hack my token and modify it because it is signed, right? But what if you want to encrypt it? So we also have an option of encrypting your JWT and by default we are not doing it here, but we can encrypt it. And that's where when you are not encrypting your token, that means anyone can see that. That's right, anyone can see your data and that's why don't put secret data in the payload.
Don't put your phone number or your social security number or your bank password. 


So if you want you can implement this in your application. So let's say we are going to build a very simple one where a user sends a request to the server by saying "I want to say hi".
And the server will say "Welcome to the Telusko". That's it, a simple API and I want to secure it. Now how we are going to do this. First step, a client will send the username and password to the server. A server will say okay, I'm verifying the username password which is correct, and now you are logged in. Now once you are logged in, the server will send a JWT token. Now this token goes to the client and it is client's responsibility to save it. And next time when a client goes to the server by saying "hey, now I want some protected resource", maybe "I want to say hi, or maybe I want to add two numbers". The server will say, who are you? Then you can say, okay, uh, hold on. When I'm sending a request, I have to also send the token.
The token goes to a server. So I will say, okay, let me wait. Let me verify your token first. And once the token is verified, a server will be able to call the API and send the response
back. That means every time you go to the server, you have to take your token with you. And of course, it should be done before token expires. Now, if you want to implement this in your application, we have to use some library for JWT. And you're going to see that in the code. But we have to add multiple mechanisms here. First we have to have a library.
Now using this library you will be creating a token. So of course you have to do a login. And once it is logged in you have to create a token. So you are responsible to create the token.
Next you have to send this token to the client. And when a client sends a next request, a client will send a token. And it is your job to verify the token. So you have multiple steps to do. And the upcoming code will not be that simple. I will try to make it simple, but once you complete the entire code, you can go through it and things will make sense.
So yeah we have we just have two tasks here. Create a token and verify the token.
